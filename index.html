<div style="position: relative;">
    <canvas id="grid" width="800" height="800" style="position: absolute; left: 0; top: 0; z-index: 0;"></canvas>
</div>

<script>

// Initialize 2D array
let size = 200, grid = [];
for (let i = 0; i < size; i++) {
    grid[i] = new Array(size).fill('W')
}


generateMaze(20, 0);
console.log(grid);

function random(length) {
    return Math.floor(Math.random() * length)
}

function computeFrontier(i, j) {
    let frontiers = [];
    // check for walls and filter out edges
    if (i-1 > 0 && grid[i-1][j] == 'W') frontiers.push([i-1, j, 'north'])
    if (i+1 < size-1 && grid[i+1][j] == 'W') frontiers.push([i+1, j, 'south'])
    if (j+1 < size-1 && grid[i][j+1] == 'W') frontiers.push([i, j+1, 'east'])
    if (j-1 > 0 && grid[i][j-1] == 'W') frontiers.push([i, j-1, 'west'])

    return frontiers;
}

function generateMaze(i, j) {
    grid[i][j] = '.';
    let frontier, fi, fj, fIndex;
    let frontiers = computeFrontier(i, j);
    let end = false;
    while (frontiers.length > 0) {
        // Select random frontier
        fIndex = random(frontiers.length); frontier = frontiers[fIndex]; fi = frontier[0]; fj = frontier[1];

        // Search for available neighbors and confirm path
        if (frontier[2] == 'north' && grid[fi-1][fj] == 'W' && grid[fi][fj+1] == 'W' && grid[fi][fj-1] == 'W') {  
            grid[fi][fj] = '.';
            // Add new frontiers
            frontiers = frontiers.concat(computeFrontier(fi, fj));
        } 
        else if (frontier[2] == 'south' && grid[fi+1][fj] == 'W' && grid[fi][fj+1] == 'W' && grid[fi][fj-1] == 'W') {
            grid[fi][fj] = '.';
            frontiers = frontiers.concat(computeFrontier(fi, fj));
        }
        else if (frontier[2] == 'east' && grid[fi+1][fj] == 'W' && grid[fi-1][fj] == 'W' && grid[fi][fj+1] == 'W') {
            grid[fi][fj] = '.';
            frontiers = frontiers.concat(computeFrontier(fi, fj));
        }
        else if (frontier[2] == 'west' && grid[fi+1][fj] == 'W' && grid[fi-1][fj] == 'W' && grid[fi][fj-1] == 'W') {
            grid[fi][fj] = '.';
            frontiers = frontiers.concat(computeFrontier(fi, fj));
        }
        // remove frontier from list
        frontiers.splice(fIndex, 1);
        // Designate end cell
        if (!end && fj == size-2) { 
            grid[fi][size-1] = '.';
            end = true;
        }
    }
    draw(800, i, j);
}

function draw(s, si, sj) {
    var canvas = document.getElementById('grid');
    var ctx = canvas.getContext('2d');
    ctx.canvas.width = s; 
    ctx.canvas.height = s;
    let delta = s/size;
    let loc = [si, sj];

    // Draw grid
    for (let i = 0; i < size; i++) {
        for (let j = 0; j < size; j++) {
            if (grid[i][j] == 'W') ctx.fillRect(j*delta, i*delta, delta, delta)
        }
    }

    // Start
    ctx.fillStyle = 'red';
    ctx.fillRect(loc[1]*delta, loc[0]*delta, delta, delta);

    // Interact
    document.addEventListener('keydown', e => {
        if (e.code == 'ArrowUp' && grid[loc[0]-1][loc[1]] == '.') {
            ctx.clearRect(loc[1]*delta, loc[0]*delta, delta, delta);
            loc[0]--
            ctx.fillRect(loc[1]*delta, loc[0]*delta, delta, delta);
        } else if (e.code == 'ArrowDown' && grid[loc[0]+1][loc[1]] == '.') {
            ctx.clearRect(loc[1]*delta, loc[0]*delta, delta, delta);
            loc[0]++
            ctx.fillRect(loc[1]*delta, loc[0]*delta, delta, delta);
        } else if (e.code == 'ArrowRight' && grid[loc[0]][loc[1]+1] == '.') {
            ctx.clearRect(loc[1]*delta, loc[0]*delta, delta, delta);
            loc[1]++
            ctx.fillRect(loc[1]*delta, loc[0]*delta, delta, delta);
        } else if (e.code == 'ArrowLeft' && grid[loc[0]][loc[1]-1] == '.') {
            ctx.clearRect(loc[1]*delta, loc[0]*delta, delta, delta);
            loc[1]--
            ctx.fillRect(loc[1]*delta, loc[0]*delta, delta, delta);
        }
    });
}

</script>